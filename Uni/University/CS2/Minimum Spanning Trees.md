# Definition
- Given a connected and undirected graph, a **spanning tree** of that graph is a subgraph that is a tree and connects all the vertices together
- It means the spanning tree has every vertex
	- (|V| - 1) edges
	- No cycle
- A graph can have multiple different spanning trees, similar to topological sort
- In a **MINIMUM SPANNING TREE**:
	- You have to find the spanning tree that costs the minimum edge weight compared to every other spanning tree
- In a weighted, undirected graph it is a tree formed by connecting all of the vertices with minimal cost:
	- The MST is a ***tree*** because its acyclic
	- It's ***spanning*** because it covers every vertex
	- And it's ***minimum*** because it has the minimum cost
# Kruskal's Algorithm
- Goal is to build a forest that will finish as a tree
	- Pick lowest cost edge not yet in a tree that does not expand the set of included edges to include it
- Overall Steps:
	- 1.) Create disjoint sets based on the number of vertices (So we have |V| sets)
	- 2.) Sort all the edges in ascending order of their weight
	- 3.) Create a result edge list which is initially empty
	- 4.) Make a counter to count the number of edges in the result list
	- 5.) Repeat until (|V| - 1) edges have been added to the result edge list {
		- 1.) Pickup next item from the sorted edge list (the smallest weighted edge)
		- 2.) Perform disjoint set find operation for the picked edge's source and destination and if both of them are from same set, it means it will create a cycle, so discard this edge and continue to 5.1
		- 3.) If no cycle was found from the above step, add it to the result edge list
		- 4.) Perform union of the source and destination of the edge
		- }
	- We implement these steps using adjacency list, priority queues, and disjoint sets
- Kruskal's Algorithm Analysis:
	- Initialize disjoint set O(n), n = |V|
	- Sorting edges O(m log(m)), m = |E|
	- Loop performed m times
		- At most log n operations of disjoint sets
	- So worst case **O(m log(m)) = O(m log(n))**
	- In worst case, graph is fully connected i.e. n<sup>2</sup> edges
# Prim's Algorithm
- Goal is to build the tree incrementally
	- Pick lower cost edge connected to known (incomplete) spanning tree that does not create a cycle and expand it to include it in the tree
- Overall Steps:
	- 1.) Have a V list to keep track of the vertices already included in the MST
	- 2.) Have a Parent list to track the edges we are choosing
	- 3.) Assign a key value to all the vertices in the input graph. Initialize all the key values as **Integer.MAX_VALUE**. Assign key value as 0 for the first vertex so that it is picked first similar to Dijkstra's
	- 4.) While V list does not include all the vertices:
		- 1.) Pick a vertex *u* which is not already in V list and has minimum key value
		- 2.) Include *u* in V list
		- 3.) Update key value of all the adjacent vertices of *u* based on the following conditions:
			- Iterate through all adjacent vertices. For every adjacent vertex *v*, if weight of the edge *u* - *v* is less than previous key value of *v*, update the key value has the weight of *u* - *v* 
		- 4.) Now update parent of *v* to *u*
- Prim's Algorithm Analysis
	- If the "Pick a vertex *u* which is not already in V list and has minimum key value" is done with binary heap then **O((n+m)log(n))**